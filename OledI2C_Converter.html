<!--
Mashed together by chromoxdor and some AI

The OLED Font Converter section is based on:
https://github.com/squix78/esp8266-oled-ssd1306-font-converter/blob/master/src/main/java/ch/squix/esp8266/fontconverter/rest/FontConverterV3.java


The Glyph Editor section is based on:
https://github.com/ThingPulse/esp8266-oled-ssd1306/blob/master/resources/glyphEditor.html

Copyright (c) 2017 by Xavier Grosjean

Based on work 
Copyright (c) 2016 by Daniel Eichhorn
Copyright (c) 2016 by Fabrice Weinberg

-->

<!DOCTYPE html>
<html lang="en">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<head>
  <meta charset="utf-8">
  <title>OLED Font Converter + Glyph Editor</title>
  <style>
    /* ========== Base Styles ========== */
    body {
      font-family: sans-serif;
      background: #97d3ef;
      display: flex;
      margin: 0;
    }

    h2,
    h3 {
      margin: 0.5rem 0;
    }

    label {
      display: block;
      font-size: 13px;
      padding: 7px 0 4px 0;
    }

    /* small helper */
    .tiny {
      font-size: 12px;
      padding: 6px 8px;
    }

    /* spin buttons in editable number inputs */
    .editable::-webkit-inner-spin-button,
    .editable::-webkit-outer-spin-button {
      opacity: 1;
    }

    /* ========== Controls ========== */
    #controls {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      gap: 15px;
      margin-bottom: 10px;
    }

    #controls>div {
      min-width: 180px;
    }

    #settingWrapper {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 10px;
      width: 450px;
      padding: 10px;
      border: 1px solid #767676;
      border-radius: 5px;
    }

    .fontSettings {
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-end;
      gap: 2px;
      align-items: center;
    }

    .buttonControls,
    #live {
      border-radius: 0 0 5px 5px;
      background: #97d3ef;
    }

    .buttonControls {
      padding: 5px 10px 5px 10px;
      gap: 5px;
      display: flex;
    }

    /* ========== Glyph Preview ========== */
    #glyphsbox {
      position: sticky;
      top: 0;
      z-index: 100;
      transition: 0.8s;
      height: 0;
      box-sizing: border-box;
      overflow-y: auto;
      resize: vertical;
      background: #97d3ef;
    }

    div#glyphs {
      display: flex;
      overflow-y: auto;
      flex-direction: row;
      flex-wrap: wrap;
      height: fit-content;
      box-sizing: border-box;
      gap: 10px;
      align-content: flex-start;
      padding: 10px;
    }

    #fButtons {
      position: sticky;
      top: 0;
      bottom: 0;
      z-index: 100;
      overflow-y: auto;
      background: #97d3ef;
    }

    .glyph {
      display: flex;
      flex-direction: column;
      align-items: center;
      height: fit-content;
      padding: 4px;
      border-radius: 4px;
      background: #eceaea;
      cursor: default;
      box-shadow: 0px 0px 3px 0px rgba(0, 0, 0, 1);
    }

    .glyph canvas {
      display: block;
      image-rendering: pixelated;
    }

    .glyph-label {
      margin-top: 4px;
      font-size: 11px;
      text-align: center;
      color: #333;
    }

    /* ========== Output ========== */
    #outputContainer {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      margin-top: 0;
    }

    #output {
      width: 100%;
      height: 260px;
      margin-top: 10px;
      padding: 8px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre;
      box-sizing: border-box;
      resize: vertical;
    }

    #generate {
      visibility: hidden;
      /* initially hidden */
      pointer-events: none;
    }

    /* ========== Editor ========== */
    #editorSection {
      display: none;
      margin-top: 22px;
      padding-top: 12px;
    }

    #editorForm table {
      width: 100%;
      border-collapse: collapse;
    }

    #editorForm td {
      padding: 4px;
      vertical-align: middle;
    }

    #editorControls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 8px;
    }

    /* ========== Character Items ========== */
    #chars {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
    }

    .char-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 6px;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: #fff;
    }

    .char-item table {
      border-collapse: collapse;
      background: transparent;
    }

    .char-item caption {
      margin-bottom: 6px;
      font-size: 12px;
      font-weight: 600;
    }

    .char-item th,
    .char-item td {
      width: 12px;
      height: 12px;
      margin: 0;
      padding: 0;
      font-size: 11px;
      text-align: center;
      box-sizing: border-box;
      border: 1px solid #ccc;
      background: #fff;
      user-select: none;
    }

    .char-item th[action] {
      font-size: 11px;
      cursor: pointer;
      background: #f2f2f2;
    }

    .char-item td.on {
      background: #00f;
    }

    .char-item td.out {
      background: #eee;
    }

    /* ========== Overlay ========== */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.7);
    }

    #overlayContent {
      padding: 20px 30px;
      font-size: 12px;
      font-weight: bold;
      color: red;
      text-align: center;
      /*border: 2px solid red;*/
      /*border-radius: 8px;*/
      background: #fff;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      font-family: 'Press Start 2P', monospace;
      line-height: 1.2;
      letter-spacing: 0.05em;
      /* make letters distinct */
      box-shadow: 0 0 0 4px red, 8px 0 0 0 red, -8px 0px 0 0 red, 0px 8px 0 0 red, 0px -8px 0 0 red;
    }

    #overlayWarning {
      position: sticky;
      top: 0;
      max-height: 100vh;
      overflow: auto;
      padding: 5px 10px;
      font-size: 16px;
      font-weight: bold;
      color: red;
      border: 2px solid red;
      border-radius: 8px;
      background: #fff;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      align-items: center;
    }

    #warningWrap {
      width: 0;
      transition: 0.4s;
    }
  </style>
</head>

<body>
  <div style="margin: 20px;width: 100%;">
    <div id="overlay" style="display:none;">
      <div id="overlayContent">
        Generating / updating font output. Please wait...
      </div>
    </div>

    <h2>OLED Font Converter</h2>
    <div id="controls" style="display:flex; justify-content: flex-start; align-items: center;">
      <div>
        <label style="font-weight:600; display:block; margin-bottom:4px;">Font file (TTF/OTF):</label>
        <input type="file" id="fontFile" accept=".ttf,.otf">
      </div>
      <div>
        <label style="font-weight:600; display:block; margin-bottom:4px;">Font URL:</label>
        <input type="url" id="fontUrl" placeholder="https://example.com/font.ttf" style="width:100%; padding:4px;">
      </div>
    </div>
    <div style="display:flex;flex-direction: column;">
      <div id="settingWrapper">

        <div id="basicFontOptions" class="fontSettings">
          <label for="fontSize" style="text-align:left;">Font size (px):</label>
          <input type="number" id="fontSize" class="editable" value="20" min="2" max="200" style="width:50px;" step="1">


          <label for="extraTop" style="text-align:left;">Extra top padding (px):</label>
          <input type="number" id="extraTop" class="editable" value="0" min="-100" max="100" style="width:50px;"
            step="1">
        </div>
        <br>


        <div id="extraFontOptions" class="fontSettings">
          <label for="extraWidth" style="text-align:left;">Extra width (px):</label>
          <input type="number" id="extraWidth" class="editable" value="0" min="-100" max="100" style="width:50px;"
            step="1">

          <label for="extraBottom" style="text-align:left;">Extra bottom padding (px):</label>
          <input type="number" id="extraBottom" class="editable" value="0" min="-100" max="100" style="width:50px;"
            step="1">
        </div>
      </div>
      <div style="display: flex;gap: 8px; align-items: center;padding: 8px;">
        <label for="boldness">Boldness:</label>

        <input type="range" id="boldness" min="1" max="254" value="128" style="width:200px;" step="1">
        <span id="boldnessValue">128</span>
        <div><button id="resetBoldness" type="button">Reset</button></div>
      </div>
      <div>
        <label for="charRange">Convert chars (ranges):</label>
        <input type="text" id="charRange" placeholder="e.g. 33-128 or 56,57,58,66-79">
      </div>
    </div>

    <div style="display:flex;gap:5px;align-items: flex-start; padding-top: 10px;padding-bottom: 10px; ">
      <button id="loadFont" class="tiny">Load & Convert</button>
      <button id="create" class="tiny">Create New</button>
    </div>


    <div id="glyphsbox" aria-label="Glyph previews">
      <div id="glyphs"></div>
    </div>

    <div id="outputContainer">
      <textarea id="output"
        placeholder="// Font output will appear here or past your font data here and press edit"></textarea>
    </div>
    <div id="fButtons" style="display:flex;gap:6px; justify-content: space-between;">
      <div style="display: flex; gap: 5px;">
        <div class="buttonControls buttonBorder">
          <button id="parse" class="tiny">Edit Font</button>
          <button id="generate" class="tiny">Update Font (q)</button>
        </div>
        <label id=live class="tiny buttonBorder">
          <input type="checkbox" id="liveUpdate">
          Live update (best for small fonts <= 20px) </label>
      </div>
      <div class="buttonControls buttonBorder">
        <button id="downloadH" class="tiny">Save to File</button>
        <button id="copyClipboard" class="tiny">Copy to Clipboard</button>
      </div>
    </div>

    <!-- Editor -->
    <div id="editorSection">
      <h2>Glyph Editor</h2>
      <div id="editorForm">
        <div style="display: flex;justify-content: flex-start;">
          <div>
            <table>
              <tr>
                <td style="width:160px">Font array name:</td>
                <td><input type="text" id="name" placeholder="My_Font" style="width:160px"></td>
                <td rowspan="4" style="width:48%"><!-- shared textarea is above; editor uses it --></td>
              </tr>
              <tr>
                <td>First char code:</td>
                <td><input type="number" id="code" value="32" style="width:160px"></td>
              </tr>
              <tr>
                <td>Width (adjustable):</td>
                <td><input type="number" id="width" class="editable" value="" style="width:160px" step="1"></td>
              </tr>
              <tr>
                <td>Height:</td>
                <td><input type="number" id="height" value="" style="width:160px" max="64" readonly></td>
              </tr>
            </table>
          </div>
          <!-- Help table -->
          <div>
            <table id="help" style="color:#666;font-size: 10px; border-collapse: collapse; width: 100%;">
              <colgroup>
                <col style="width: 30px; text-align: right;">
                <col>
              </colgroup>
              <tr>
                <td colspan="2">Draw / erase char pixels by mouse click and drag</td>
              </tr>
              <tr>
                <td colspan="2">Press 'q' to update the font manually</td>
              </tr>
              <tr>
                <td>✗</td>
                <td>Delete this char</td>
              </tr>
              <tr>
                <td>←↓↑→</td>
                <td>Move all pixels</td>
              </tr>
              <tr>
                <td>(</td>
                <td>Extend occupied width</td>
              </tr>
              <tr>
                <td>)</td>
                <td>Reduce occupied width</td>
              </tr>
              <tr>
                <td>I</td>
                <td>Import all pixels from another char</td>
              </tr>
              <tr>
                <td>C</td>
                <td>Clean all pixels of current char</td>
              </tr>
              <tr>
                <td colspan="2">"Add a character" button: Add new char at the end</td>
              </tr>
            </table>
          </div>
        </div>
        <!-- <div id="editorControls">
        <button id="parse" class="tiny">Edit Font</button>
        <button id="generate" class="tiny">Generate</button>
        <button id="create" class="tiny">Create New</button>
        <span style="color:#666;font-size:12px;">(Use Parse to import the shared font data above)</span>
      </div> -->
      </div>

      <div id="chars" role="application" aria-label="Glyph editor grids"></div>
      <button id="addCharBottom" class="tiny">+ Add Character</button>

    </div>
  </div>
  <div id="warningWrap">
    <div id="overlayWarning">
    </div>
  </div>

  <script>

    function adjustFButtonsPosition() {
      const glyphs = document.getElementById('glyphsbox');
      const fButtons = document.getElementById('fButtons');

      // get the bottom position of glyphs relative to the page
      const glyphsRect = glyphs.getBoundingClientRect();

      // Set the top of fButtons right below glyphs
      fButtons.style.top = glyphsRect.bottom - 1 + 'px';

      // Select all elements with class 'buttonBorder'
      const buttons = document.querySelectorAll('.buttonBorder');
      // Check if fButtons has reached the bottom of glyphs
      if (glyphsRect.bottom - 1 == fButtons.getBoundingClientRect().top) {
        //fButtons.style.background = 'none';
        fButtons.style.boxShadow = '0px 11px 19px -9px #000000,0px 2px 20px -9px #000000';
        fButtons.style.border = '1px solid #767676';
        fButtons.style.borderTop = 'none';
        glyphs.style.borderBottom = 'none';
        glyphs.style.boxShadow = '';

      } else {
        //fButtons.style.background = '#97d3ef';rgb(0, 0, 0) 0px 11px 19px -9px, rgb(0, 0, 0) 0px 2px 20px -9px
        fButtons.style.border = '';
        glyphs.style.boxShadow = '0px 0px 12px -2px #000000';
        fButtons.style.boxShadow = '';

      }
    }

    // Call it when glyphs is resized (using ResizeObserver)
    const glyphs = document.getElementById('glyphsbox');
    const resizeObserver = new ResizeObserver(() => {
      adjustFButtonsPosition();
    });
    resizeObserver.observe(glyphs);

    // Also adjust on window scroll / resize
    window.addEventListener('resize', adjustFButtonsPosition);
    window.addEventListener('scroll', adjustFButtonsPosition);

    const fontSizeInput = document.getElementById('fontSize');
    const extraTopInput = document.getElementById('extraTop');

    // enforce fontSize between 2 and 200
    fontSizeInput.addEventListener('input', () => {
      let val = parseInt(fontSizeInput.value, 10);
      if (isNaN(val)) return;
      if (val > 200) fontSizeInput.value = 200;
      if (val < 2) fontSizeInput.value = 2;
    });

    // enforce extraTop between 0 and 100
    extraTopInput.addEventListener('input', () => {
      let val = parseInt(extraTopInput.value, 10);
      if (isNaN(val)) return;
      if (val > 100) extraTopInput.value = 100;
      if (val < -100) extraTopInput.value = -100;
    });

    function jumpToChar(code) {
      const el = document.getElementById(`char-${code}`);
      if (el) {
        el.scrollIntoView({ behavior: "smooth", block: "center" });
        el.style.background = "yellow"; // optional highlight
        setTimeout(() => el.style.background = "", 1000);
      } else {
        alert(`Char ${code} not found`);
      }
    }
    function openGlyphTable() {
      document.getElementById('glyphsbox').style.border = "1px solid #767676";
      let glyphsHeight = document.getElementById('glyphs').offsetHeight;
      document.getElementById('glyphsbox').style.height = Math.min(glyphsHeight, 300) + "px";
    }

    /* ---------------- Converter code ---------------- */
    (async () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      let glyphs = [], fontFace, fontName = 'MyFont';
      let fontSize = 20, extraTop = 0, extraWidth = 0, extraBottom = 0;
      let pixelThreshold = 128;

      // Input elements
      const fontSizeInput = document.getElementById('fontSize');
      const extraTopInput = document.getElementById('extraTop');
      const extraWidthInput = document.getElementById('extraWidth');
      const extraBottomInput = document.getElementById('extraBottom');

      function createCanvasForGlyph(width, height) {
        canvas.width = width;
        canvas.height = height;
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = 'black';
        ctx.textBaseline = 'top';
      }

      function drawGlyph(ch, width, height) {
        createCanvasForGlyph(width, height);
        ctx.font = `${fontSize}px "${fontName}"`;

        // offset X by half of extraWidth so extra width is added to both sides
        const xOffset = Math.floor(extraWidth / 2);

        ctx.fillText(ch, xOffset, extraTop);
        return ctx.getImageData(0, 0, width, height);
      }

      function convertToBytes(imageData, width, height) {
        const boldness = parseInt(document.getElementById('boldness').value, 10) || 128;
        const arrayHeight = Math.ceil(height / 8);
        const bytes = [];

        for (let x = 0; x < width; x++) {
          for (let yBlock = 0; yBlock < arrayHeight; yBlock++) {
            let byte = 0;
            for (let bit = 0; bit < 8; bit++) {
              const y = yBlock * 8 + bit;
              if (y >= height) continue;
              const idx = (y * width + x) * 4;
              const a = imageData.data[idx + 3];
              if (a >= (255 - boldness)) byte |= 1 << bit;
            }
            bytes.push(byte);
          }
        }

        // trim trailing zeros but keep at least one block
        let lastNonZero = -1;
        for (let i = 0; i < bytes.length; i++) if (bytes[i] !== 0) lastNonZero = i;
        if (lastNonZero < 0) lastNonZero = bytes.length - 1;
        return bytes.slice(0, lastNonZero + 1);
      }

      function hex(b) { return '0x' + b.toString(16).padStart(2, '0').toUpperCase(); }

      function renderGlyphs(scale = 3) { // default scale 3x
        const container = document.getElementById('glyphs');
        container.innerHTML = '';

        glyphs.forEach(g => {
          const div = document.createElement('div');
          div.className = 'glyph';
          div.id = `#${g.code}`;

          const c = document.createElement('canvas');
          c.width = g.width * scale;   // scale width
          c.height = g.height * scale; // scale height
          const cctx = c.getContext('2d');

          // Fill background
          cctx.fillStyle = 'white';
          cctx.fillRect(0, 0, c.width, c.height);

          cctx.fillStyle = 'black';
          for (let x = 0; x < g.width; x++) {
            for (let y = 0; y < g.height; y++) {
              const yBlock = Math.floor(y / 8);
              const bit = y % 8;
              const idx = x * g.arrayHeight + yBlock;
              if (g.bytes[idx] & (1 << bit)) {
                cctx.fillRect(x * scale, y * scale, scale, scale); // scale each pixel
              }
            }
          }

          div.appendChild(c);

          const label = document.createElement('div');
          label.className = 'glyph-label';
          label.textContent = `#${g.code} [${String.fromCharCode(g.code)}]`;
          div.appendChild(label);

          container.appendChild(div);
        });
      }

      const boldnessSlider = document.getElementById('boldness');
      const boldnessValue = document.getElementById('boldnessValue');
      const loadFontBtn = document.getElementById('loadFont');
      const resetBoldnessBtn = document.getElementById('resetBoldness');
      const fileInput = document.getElementById('fontFile');
      const urlInput = document.getElementById('fontUrl');

      let updateTimer = null;
      function scheduleUpdate() {
        let file = fileInput.files[0];
        if (!file && !urlInput.value.trim()) return;
        clearTimeout(updateTimer);
        updateTimer = setTimeout(() => loadFontBtn.click(), 400);
      }

      fontSizeInput.addEventListener('input', scheduleUpdate);
      extraTopInput.addEventListener('input', scheduleUpdate);
      extraWidthInput.addEventListener('input', scheduleUpdate);
      extraBottomInput.addEventListener('input', scheduleUpdate);

      boldnessSlider.addEventListener('change', () => {
        boldnessValue.textContent = boldnessSlider.value;
        if (glyphs.length > 0) loadFontBtn.click();
      });

      resetBoldnessBtn.addEventListener('click', () => {
        boldnessSlider.value = 128;
        boldnessValue.textContent = "128";
        if (glyphs.length > 0) loadFontBtn.click();
      });

      document.getElementById('loadFont').addEventListener('click', async () => {
        document.getElementById('editorSection').style.display = 'none';
        fontSize = parseInt(fontSizeInput.value) || 20;
        extraTop = parseInt(extraTopInput.value) || 0;
        extraWidth = parseInt(extraWidthInput.value) || 0;
        extraBottom = parseInt(extraBottomInput.value) || 0;

        let file = fileInput.files[0];
        try {
          if (!file && urlInput.value.trim()) {
            const response = await fetch(urlInput.value.trim());
            if (!response.ok) throw new Error("Could not fetch font from URL.");
            const arrayBuffer = await response.arrayBuffer();
            const fontData = new Uint8Array(arrayBuffer);
            file = new File([fontData], urlInput.value.trim().split('/').pop() || "remoteFont.ttf", { type: "font/ttf" });
          }

          if (!file) { alert('Please select a font file or enter a font URL'); return; }

          fontName = file.name.replace(/\.[^.]+$/, '').replace(/\s+/g, '_');
          fontFace = new FontFace(fontName, `url(${URL.createObjectURL(file)})`);
          await fontFace.load();
          document.fonts.add(fontFace);

          let maxWidth = 0;
          let maxHeight = fontSize + extraTop + extraBottom;

          ctx.font = `${fontSize}px "${fontName}"`;
          for (let code = 32; code < 256; code++) {
            const w = Math.ceil(ctx.measureText(String.fromCharCode(code)).width) + extraWidth;
            if (w > maxWidth) maxWidth = w;
          }

          let maxChar = 255; // default max if no input
          let minChar = 32;  // default min
          const rangeInput = document.getElementById('charRange')?.value.trim();
          let selectedChars = null;

          if (rangeInput) {
            selectedChars = new Set();
            maxChar = 32;      // reset for range calculation
            minChar = Infinity; // track the lowest valid char
            let minInvalidChar = Infinity;

            rangeInput.split(',').map(s => s.trim()).forEach(part => {
              if (part.includes('-')) {
                const [start, end] = part.split('-').map(Number);
                if (!isNaN(start) && !isNaN(end) && start <= end) {
                  for (let i = start; i <= end; i++) {
                    if (i >= 32) { // ignore below 32
                      selectedChars.add(i);
                      if (i > maxChar) maxChar = i;
                      if (i < minChar) minChar = i;
                    } else {
                      minInvalidChar = Math.min(minInvalidChar, i);
                    }
                  }
                }
              } else {
                const n = Number(part);
                if (!isNaN(n)) {
                  if (n >= 32) {
                    selectedChars.add(n);
                    if (n > maxChar) maxChar = n;
                    if (n < minChar) minChar = n;
                  } else {
                    minInvalidChar = Math.min(minInvalidChar, n);
                  }
                }
              }
            });

            if (minInvalidChar < 32) {
              alert(`Warning: characters below 32 are ignored (minimum char is 32).`);
            }

            // if only invalid chars were entered
            if (minChar === Infinity) {
              minChar = 32;
              maxChar = 255;
              selectedChars = null;
            }
          } else {
            minChar = 32;  // no input → normal full range
            maxChar = 255;
          }

          // -------- Generate glyphs --------
          glyphs = [];
          for (let code = minChar; code <= maxChar; code++) {
            const ch = String.fromCharCode(code);
            const w = Math.max(1, Math.ceil(ctx.measureText(ch).width) + extraWidth);

            if (!selectedChars || selectedChars.has(code)) {
              const img = drawGlyph(ch, w, maxHeight);
              const bytes = convertToBytes(img, w, maxHeight, pixelThreshold);
              glyphs.push({
                code,
                bytes: bytes.length ? bytes : new Array(Math.ceil(maxHeight / 8) * w).fill(0),
                width: w,
                height: maxHeight,
                arrayHeight: Math.ceil(maxHeight / 8)
              });
            } else {
              // Not in range → blank glyph
              glyphs.push({
                code,
                bytes: new Array(Math.ceil(maxHeight / 8) * w).fill(0),
                width: w,
                height: maxHeight,
                arrayHeight: Math.ceil(maxHeight / 8)
              });
            }
          }
          renderGlyphs();
          openGlyphTable();

          let jumpOffset = 0;
          let warnings = [];
          let useUint16 = false;

          // -------- Output header --------
          let out = `// OLED Font edited from ${file.name}\n`;
          const type = useUint16 ? "uint16_t" : "char"; // will be updated later if needed
          out += `const ${type} ${fontName}_${fontSize}[] PROGMEM = {\n`;
          out += `\t${hex(maxWidth)}, // Width: ${maxWidth}\n`;
          out += `\t${hex(maxHeight)}, // Height: ${maxHeight}\n`;
          out += `\t${hex(minChar)}, // First Char: ${minChar}\n`;
          out += `\t${hex(maxChar - minChar + 1)}, // Number of chars: ${maxChar - minChar + 1}\n\n\t// Jump Table:\n`;

          // -------- Overflow detection + Jump table build --------
          glyphs.forEach(g => {
            const isBlank = g.bytes.every(b => b === 0);
            if (isBlank) {
              // Blank glyph marker
              out += `\t0xFF, 0xFF, 0x00, ${hex(g.width)}, // ${g.code} '${String.fromCharCode(g.code)}' (blank)\n`;
            } else {
              if (g.bytes.length) {
                if (g.bytes.length > 0xFF) {
                  warnings.push(
                    `Glyph ${g.code} '${String.fromCharCode(g.code)}' → ` +
                    `Length: ${g.bytes.length} (max 255)`
                  );
                  useUint16 = true;
                }

                out += `\t${hex((jumpOffset >> 8) & 0xFF)}, ${hex(jumpOffset & 0xFF)}, ${hex(g.bytes.length)}, ${hex(g.width)}, // ${g.code} '${String.fromCharCode(g.code)}'\n`;
                jumpOffset += g.bytes.length;
              } else {
                out += `\t0xFF, 0xFF, 0x00, 0x00, // ${g.code} '' (empty)\n`;
              }
            }
          });


          // -------- Warnings --------
          const overlayWarning = document.getElementById("overlayWarning");
          const warningWrap = document.getElementById("warningWrap");
          if (warnings.length) {
            overlayWarning.innerHTML = `
                                      <div>
                                        ⚠️ Overflow detected in ${warnings.length} glyph(s)
                                        <br><br>
                                        Reduce font size or decrease the width of problematic glyphs manually.
                                        Or consider switching to <code>uint16_t</code> (library needs to be adjusted).
                                      </div>
                                      <pre style="white-space: pre-wrap;font-size: 10px;">${warnings.join("\n")}</pre>
                                      `;
            overlayWarning.style.display = "block";
            overlayWarning.style.right = "0";
            warningWrap.style.width = "450px";
          } else {
            overlayWarning.innerHTML = "";
            warningWrap.style.width = "0";
          }

          // -------- Font Data --------
          out += '\n\t// Font Data:\n';
          glyphs.forEach(g => {
            // Check if the glyph is blank (all bytes zero)
            const isBlank = g.bytes.every(b => b === 0);

            if (!isBlank && g.bytes.length) {
              // Only write non-blank glyphs
              out += '\t' + g.bytes.map(b => hex(b)).join(',') + `, // ${g.code} '${String.fromCharCode(g.code)}'\n`;
            } else if (isBlank) {
              // Optionally add a comment for clarity, but do NOT write bytes
              // out += `\t// ${g.code} '${String.fromCharCode(g.code)}'\n`;
            }
          });
          out += '};\n';
          document.getElementById('output').value = out;

        } catch (err) {
          console.error(err);
          alert("Error loading font: " + err.message);
        }
      });

      document.getElementById('downloadH').addEventListener('click', () => {
        const data = document.getElementById('output').value;
        if (!data.trim()) { alert('Nothing to save.'); return; }
        const blob = new Blob([data], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const editName = document.getElementById("name")?.value.trim();
        a.download = `${editName && editName.length > 0 ? editName : fontName + '_' + fontSize}.h`; a.click();
      });

      document.getElementById('copyClipboard').addEventListener('click', () => {
        const out = document.getElementById('output');
        out.select();
        document.execCommand('copy');
        alert('Font array copied to clipboard!');
      });
    })();

    /* ---------------- Glyph editor (parser + grid) ---------------- */
    (function () {
      let editorFont = null, isMouseDown = false, paintState = null;

      function prs(token) {
        token = (token || '').trim();
        if (!token.length) return NaN;
        if (/^0x/i.test(token)) return parseInt(token, 16);
        if (/^[Bb][01]+$/.test(token)) return parseInt(token.slice(1), 2);
        return parseInt(token, 10);
      }

      class FontEditor {
        constructor() {
          this.height = parseInt(document.getElementById('height').value) || 8;
          this.width = parseInt(document.getElementById('width').value) || 8;
          this.currentCharCode = parseInt(document.getElementById('code').value) || 32;
          this.fontContainer = document.getElementById('chars');
          this.bytesForHeight = Math.ceil(this.height / 8);
          this.fontContainer.innerHTML = '';
          document.body.classList.add('started');
        }

        static updateCaption(captionEl, code) { captionEl.textContent = `#${code} [${String.fromCharCode(code)}]`; }

        addChar(jumpData, charData) {
          const wrapper = document.createElement('div');
          wrapper.className = 'char-item';
          const tbl = document.createElement('table');

          // Create caption and assign ID
          const caption = tbl.appendChild(document.createElement('caption'));
          caption.id = `char-${this.currentCharCode}`;
          FontEditor.updateCaption(caption, this.currentCharCode);

          const header = tbl.appendChild(document.createElement('tr'));
          header.innerHTML =
            '<th action="delete">&cross;</th>' +
            //'<th action="add">+</th>' +
            '<th action="tight">)</th>' +
            '<th action="left">&larr;</th>' +
            '<th action="down">&darr;</th>' +
            '<th action="up">&uarr;</th>' +
            '<th action="right">&rarr;</th>' +
            '<th action="release">(</th>' +
            '<th action="copy">I</th>' +
            '<th action="clean">C</th>';

          wrapper.jumpData = jumpData || [0, 0, 0, this.width]; // store xAdvance info

          let pixelInit = [];
          if (Array.isArray(charData) && charData.length) {
            const colBytes = charData.slice();
            const missing = colBytes.length % this.bytesForHeight;
            for (let i = 0; i < missing; i++) colBytes.push(0);
            while (colBytes.length) {
              const rowBytes = colBytes.splice(0, this.bytesForHeight).reverse();
              const pixelRow = [];
              for (let b = 0; b < rowBytes.length; b++) {
                let mask = 0x80;
                let byte = rowBytes[b];
                for (let bit = 0; bit < 8; bit++) {
                  pixelRow.push((byte & mask) ? 1 : 0);
                  mask >>= 1;
                }
              }
              pixelRow.splice(0, pixelRow.length - this.height);
              pixelInit.push(pixelRow.reverse());
            }
          }

          for (let r = 0; r < this.height; r++) {
            const row = tbl.appendChild(document.createElement('tr'));
            for (let c = 0; c < this.width; c++) {
              const td = row.appendChild(document.createElement('td'));
              td.setAttribute('action', 'toggle');
              if (pixelInit.length && pixelInit[c] && pixelInit[c][r]) td.className = 'on';
              if (Array.isArray(jumpData) && jumpData.length >= 4) {
                if (c >= jumpData[3]) td.classList.add('out');
              }
            }
          }

          wrapper.appendChild(tbl);
          this.fontContainer.appendChild(wrapper);
          this.currentCharCode++;
          return wrapper;
        }

        static togglePixel(cell) { if (!cell || cell.classList.contains('out')) return; cell.classList.toggle('on'); }
      }

      let warnings = [];
      FontEditor.prototype.generate = function () {
        const outputEl = document.getElementById('output');
        const chars = this.fontContainer.getElementsByTagName('table');
        const firstCharCode = parseInt(document.getElementById('code').value);
        const name = document.getElementById('name').value.replace(/[^a-zA-Z0-9_$]/g, '_');

        const bits2add = this.bytesForHeight * 8 - this.height;
        let charAddr = 0;

        const jumpLines = [];
        const dataLines = [];
        const width = parseInt(document.getElementById('width')?.value, 10) || this.width;

        warnings = [];
        let useUint16 = false;
        console.log(chars.length)
        for (let ch = 0; ch < chars.length; ch++) {
          const table = chars[ch];
          const rows = table.getElementsByTagName('tr');

          const jumpData = table.jumpData || table.parentNode?.jumpData || [0, 0, 0, this.width];
          const xAdvance = jumpData[3] ?? this.width;

          let charBytes = [];
          let notZero = false;

          for (let col = 0; col < xAdvance; col++) {
            let bits = "";
            for (let r = rows.length - 1; r >= 1; r--) { // skip header row
              const cell = rows[r].children[col];
              if (!cell) continue;
              bits += cell.classList.contains('on') ? '1' : '0';
            }

            // pad to full byte blocks
            for (let b = 0; b < bits2add; b++) bits = '0' + bits;

            for (let b = bits.length - 1; b >= 7; b -= 8) {
              const byteStr = bits.substr(b - 7, 8);
              const byte = parseInt(byteStr, 2);
              if (byte !== 0) notZero = true;
              charBytes.push(byte);
            }
          }

          // remove trailing zeros
          while (charBytes.length > 1 && charBytes[charBytes.length - 1] === 0) charBytes.pop();

          const charCode = ch + firstCharCode;
          if (notZero) {
            // Check overflow for jump table / byte length
            if (charBytes.length > 0xFF) {

              warnings.push(
                `Glyph ${charCode} '${String.fromCharCode(charCode)}' → Length: ${charBytes.length} (max 255)`
              );
              //useUint16 = true;
            }

            // Font data line
            dataLines.push(
              `\t${charBytes.map(b => '0x' + b.toString(16).padStart(2, '0').toUpperCase()).join(',')}, // ${charCode} '${String.fromCharCode(charCode)}'`
            );

            // Jump table line
            jumpLines.push(
              `\t0x${((charAddr >> 8) & 0xFF).toString(16).padStart(2, '0').toUpperCase()}, ` +
              `0x${(charAddr & 0xFF).toString(16).padStart(2, '0').toUpperCase()}, ` +
              `0x${charBytes.length.toString(16).padStart(2, '0').toUpperCase()}, ` +
              `0x${xAdvance.toString(16).padStart(2, '0').toUpperCase()}, // ${charCode} '${String.fromCharCode(charCode)}'`
            );

            charAddr += charBytes.length;
          } else {
            // empty glyph
            jumpLines.push(
              `\t0xFF, 0xFF, 0x00, 0x${xAdvance.toString(16).padStart(2, '0').toUpperCase()}, // ${charCode} '${String.fromCharCode(charCode)}' (blank)`
            );
          }
        }



        const type = useUint16 ? "uint16_t" : "char";

        // -------- Output --------
        outputEl.value = `// OLED Font edited by Glyph Editor
const ${type} ${name}[] PROGMEM = {
\t0x${width.toString(16).padStart(2, '0').toUpperCase()}, // Width: ${width}
\t0x${this.height.toString(16).padStart(2, '0').toUpperCase()}, // Height: ${this.height}
\t0x${firstCharCode.toString(16).padStart(2, '0').toUpperCase()}, // First Char: ${firstCharCode}
\t0x${chars.length.toString(16).padStart(2, '0').toUpperCase()}, // Number of chars: ${chars.length}

\t// Jump Table:
${jumpLines.join('\n')}

\t// Font Data:
${dataLines.join('\n')}
};`;

        // Re-render preview with updated xAdvance
        this.renderGlyphs(3);

        // -------- Warnings Overlay --------
        const overlayWarning = document.getElementById("overlayWarning");
        const warningWrap = document.getElementById("warningWrap");
        if (warnings.length) {
          overlayWarning.innerHTML = `
                                      <div>
                                        ⚠️ Overflow detected in ${warnings.length} glyph(s)
                                        <br><br>
                                        Reduce font size or decrease the width of problematic glyphs manually.
                                        Or consider switching to <code>uint16_t</code> (library needs to be adjusted).
                                      </div>
                                      <pre style="white-space: pre-wrap;font-size: 10px;">${warnings.join("\n")}</pre>
                                      `;
          overlayWarning.style.display = "block";
          overlayWarning.style.right = "0";
          warningWrap.style.width = "450px";
        } else {
          overlayWarning.innerHTML = "";
          warningWrap.style.width = "0";
        }

      };

      FontEditor.prototype.toGlyphs = function () {
        const glyphs = [];
        const tables = this.fontContainer.getElementsByTagName('table');

        for (let i = 0; i < tables.length; i++) {
          const tbl = tables[i];
          const rows = tbl.getElementsByTagName('tr');
          const bytes = [];

          for (let col = 0; col < this.width; col++) {
            let colBits = 0;
            let bitIdx = 0;

            // Start at row 1 to skip the header
            for (let row = 1; row <= this.height; row++) {
              const cell = rows[row]?.children[col];
              if (cell?.classList.contains('on')) {
                colBits |= (1 << bitIdx);
              }
              bitIdx++;
              if (bitIdx === 8) {
                bytes.push(colBits);
                colBits = 0;
                bitIdx = 0;
              }
            }
            if (bitIdx > 0) bytes.push(colBits); // remaining bits
          }

          glyphs.push({
            code: i + parseInt(document.getElementById('code').value),
            width: this.width,
            height: this.height,
            arrayHeight: this.bytesForHeight,
            bytes: bytes
          });
        }
        return glyphs;
      };

      FontEditor.prototype.renderGlyphs = function (scale = 3) {
        const container = document.getElementById('glyphs');
        container.innerHTML = '';
        const glyphs = this.toGlyphs(); // uses the editor grid

        glyphs.forEach((g, i) => {
          const div = document.createElement('div');
          div.className = 'glyph';

          // Use xAdvance if available
          let xAdvance = this.width;
          const tbl = this.fontContainer.children[i];
          if (tbl?.jumpData?.length >= 4) xAdvance = tbl.jumpData[3];

          const c = document.createElement('canvas');
          c.width = xAdvance * scale;
          c.height = g.height * scale;
          const ctx = c.getContext('2d');

          // Draw background
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, c.width, c.height);

          // Draw pixels
          ctx.fillStyle = 'black';
          for (let x = 0; x < xAdvance; x++) {
            for (let y = 0; y < g.height; y++) {
              const yBlock = Math.floor(y / 8);
              const bit = y % 8;
              const idx = x * g.arrayHeight + yBlock;
              if (g.bytes[idx] & (1 << bit)) {
                ctx.fillRect(x * scale, y * scale, scale, scale);
              }
            }
          }

          div.appendChild(c);
          const label = document.createElement('div');
          label.className = 'glyph-label';
          label.textContent = `#${g.code} [${String.fromCharCode(g.code)}]`;
          div.appendChild(label);

          container.appendChild(div);
        });
      };

      // parse button event
      document.getElementById('parse').addEventListener('click', function () {
        pendingGeneration();
        setTimeout(() => {
          parseFont(true);
        }, 50); // 50ms is enough for repaint
      });

      function parseFont(bPressed = false) {

        const txt = document.getElementById('output').value || '';
        if (!txt.trim()) { alert('Shared output is empty'); hideOverlay(); return; }
        const cleaned = txt.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1').trim();
        const nameMatch = cleaned.match(/const\s+\w+\s+(.+?)\s*\[\]/);
        const fontArrayName = nameMatch ? nameMatch[1] : '';
        document.getElementById('name').value = fontArrayName;
        const inside = (cleaned.split('{').slice(1).join('{') || '').split('}')[0];
        if (!inside) { alert('Could not find array data'); return; }
        const tokens = inside.split(',').map(s => s.trim()).filter(s => s.length);
        if (tokens.length < 4) { alert('Not enough data'); return; }
        const width = prs(tokens[0]), height = prs(tokens[1]), firstCharCode = prs(tokens[2]), numberOfChars = prs(tokens[3]);
        if (isNaN(width) || isNaN(height) || isNaN(firstCharCode) || isNaN(numberOfChars)) { alert('Header parse failed'); return; }

        let jc = 4, dc = 4 + 4 * numberOfChars, jumpTable = [], charData = [];
        for (let c = 0; c < numberOfChars; c++) {
          const je = [];
          for (let j = 0; j < 4; j++) je.push(prs(tokens[jc++]));
          jumpTable.push(je);
          if (!(je[0] === 255 && je[1] === 255)) {
            for (let k = 0; k < je[2]; k++) charData.push(prs(tokens[dc++]));
          }
        }

        document.getElementById('width').value = width;
        document.getElementById('height').value = height;
        document.getElementById('code').value = firstCharCode;

        editorFont = new FontEditor();
        let cdPtr = 0;
        for (let i = 0; i < jumpTable.length; i++) {
          const je = jumpTable[i];
          let chBytes = [];
          if (!(je[0] === 255 && je[1] === 255) && je[2] > 0) {
            chBytes = charData.slice(cdPtr, cdPtr + je[2]);
            cdPtr += je[2];
          }
          editorFont.addChar(je, chBytes);
        }
        editorFont.renderGlyphs(3); // 2x scale
        if (bPressed) {
          srollToEditor();
          hideOverlay();
        }
        getGlyphs()
      }

      document.getElementById('create').addEventListener('click', () => {
        if (!confirm("Do you really want to create a new font? This will clear the current editor.")) {
          return; // cancelled
        }

        // Ask user for height
        const inputHeight = prompt("Enter font height (1–128 pixels):", "20");
        if (inputHeight === null) return; // cancelled

        const h = parseInt(inputHeight, 10);
        if (isNaN(h) || h < 1 || h > 128) {
          alert("Invalid height! Please enter a value between 1 and 128.");
          return;
        }

        const w = parseInt(document.getElementById('width').value) || 8;
        const code = parseInt(document.getElementById('code').value) || 32;

        document.getElementById('width').value = w;
        document.getElementById('height').value = h;
        document.getElementById('name').value = 'My_Font';
        document.getElementById('output').value = '';

        editorFont = new FontEditor();
        editorFont.addChar();
        srollToEditor();
        generateF();
      });

      document.getElementById('generate').addEventListener('click', () => {
        document.getElementById('generate').style.visibility = 'hidden';
        document.getElementById('generate').style.pointerEvents = 'none';
        generateF();
      });

      function generateF() {
        if (!editorFont) {
          alert('No font in editor');
          return;
        }
        isGenerating = true
        console.log('Generate font from editor');
        // Show overlay first
        pendingGeneration();

        // Give browser a moment to render overlay
        setTimeout(() => {
          editorFont.generate(); // heavy generation
          parseFont();           // update preview
          hideOverlay();
        }, 50); // 50ms is enough for repaint

        setTimeout(() => {
          isGenerating = false;        // hide overlay after done
        }, 1000); // 50ms is enough for repaint
      }

      function pendingGeneration() {
        const overlay = document.getElementById('overlay');
        overlay.style.display = 'flex';
      }

      function hideOverlay() {
        const overlay = document.getElementById('overlay');
        overlay.style.display = 'none';
      }


      document.getElementById('addCharBottom').addEventListener('click', () => { if (editorFont) editorFont.addChar(); waitforGenerateF(); });
      document.getElementById('width').addEventListener('input', function () {
        waitforGenerateF();

      });
      document.getElementById('name').addEventListener('input', function () {
        waitforGenerateF();

      });

      function srollToEditor() {
        openGlyphTable();
        document.getElementById('editorSection').style.display = 'block';
        const targetDiv = document.getElementById('editorSection'); // or any div
        const rect = targetDiv.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

        // Scroll to 350px above the div
        const targetPosition = scrollTop + rect.top - 350;

        window.scrollTo({ top: targetPosition, behavior: 'smooth' });
      }

      document.addEventListener("keydown", (event) => {
        // Only trigger on "u" key (lowercase)
        if (event.key === "q") {
          event.preventDefault(); // stop typing 'u' into inputs
          generateF();
        }
      });
      function getGlyphs() {
        document.querySelectorAll('.glyph').forEach(glyphDiv => {
          glyphDiv.style.cursor = 'pointer'; // indicate clickable
          glyphDiv.addEventListener('click', () => {
            const label = glyphDiv.querySelector('.glyph-label');
            if (!label) return;

            // Extract the number after the # sign
            const match = label.textContent.match(/^#(\d+)/);
            if (match) {
              const charCode = parseInt(match[1], 10);
              jumpToChar(charCode); // call your jump function
            }
          });
        });
      }

      /* ---------------- Interaction: click, hold & drag, actions ---------------- */

      // pointerdown handles both toggling pixels and action buttons
      document.getElementById('chars').addEventListener('pointerdown', function (e) {
        if (e.button !== 0) return; // left button only

        const target = e.target.closest('td[action="toggle"], th[action]');
        if (!target) return;
        waitforGenerateF()
        const action = target.getAttribute('action') || '';

        if (action && action !== 'toggle') {
          const th = target;
          const table = th.closest('table');
          const wrapper = table.closest('.char-item');
          const pixels = table.getElementsByTagName('td');
          switch (action) {
            /*case 'add': {
              const code = wrapper.querySelector('caption')?.textContent?.match(/\d+/)?.[0] || document.getElementById('code').value;
              const newItem = editorFont.addChar();
              wrapper.parentNode.insertBefore(newItem, wrapper);
              let codeVal = parseInt(code);
              let cur = newItem;
              while (cur) {
                const cap = cur.querySelector('caption');
                if (cap) FontEditor.updateCaption(cap, codeVal);
                codeVal++;
                cur = cur.nextSibling;
              }
              waitforGenerateF();
            } break;*/
            case 'delete': {
              if (confirm('Delete this character ?')) {
                // Clear all pixels
                const pixels = wrapper.querySelectorAll('td');
                pixels.forEach(cell => cell.className = 'out');

                // Optional: reset xAdvance or width if you track it
                if (wrapper.jumpData) wrapper.jumpData[3] = 0;

                // Keep caption unchanged or reset if needed
                const cap = wrapper.querySelector('caption');
                if (cap) cap.textContent = `${cap.textContent.split(' ')[0]} (empty)`;
              }
              console.log('delete char');
              //waitforGenerateF(); // call the delayed regenerate
            } break;
            case 'left': {
              for (let p = 0; p < pixels.length; p++) {
                if ((p + 1) % editorFont.width) {
                  pixels[p].className = pixels[p + 1].className;
                } else pixels[p].className = 'out';
              }
              //waitforGenerateF();
            } break;
            case 'right': {
              for (let p = pixels.length - 1; p >= 0; p--) {
                if (p % editorFont.width) {
                  pixels[p].className = pixels[p - 1].className;
                } else pixels[p].className = '';
              }
              //waitforGenerateF();
            } break;
            case 'up': {
              for (let p = 0; p < pixels.length; p++) {
                if (p < editorFont.width * (editorFont.height - 1)) {
                  pixels[p].className = pixels[p + editorFont.width].className;
                } else {
                  pixels[p].className = pixels[p].classList.contains('out') ? 'out' : '';
                }
              }
              //waitforGenerateF();
            } break;
            case 'down': {
              for (let p = pixels.length - 1; p >= 0; p--) {
                if (p >= editorFont.width) {
                  pixels[p].className = pixels[p - editorFont.width].className;
                } else {
                  pixels[p].className = pixels[p].classList.contains('out') ? 'out' : '';
                }
              }
              //waitforGenerateF();
            } break;
            case 'tight':
            case 'release':
              if (action === 'tight') {
                for (let p = 0; p < pixels.length; p++) {
                  if ((p + 1) % editorFont.width) {
                    if (pixels[p + 1].classList.contains('out')) pixels[p].classList.add('out');
                  } else pixels[p].classList.add('out');
                }
              } else {
                for (let p = pixels.length - 1; p >= 0; p--) {
                  if ((p % editorFont.width) && pixels[p].classList.contains('out') && !pixels[p - 1].classList.contains('out')) {
                    pixels[p].className = '';
                  }
                }
              }
              // recalc xAdvance after tight/release
              if (!table.jumpData) table.jumpData = [0, 0, 0, editorFont.width];
              let xAdv = 0;
              for (let col = 0; col < editorFont.width; col++) {
                for (let row = 0; row < editorFont.height; row++) {
                  const cell = pixels[row * editorFont.width + col];
                  if (cell && !cell.classList.contains('out')) xAdv = col + 1;
                }
              }
              table.jumpData[3] = xAdv;
              //waitforGenerateF();
              break;
            case 'clean':
              if (confirm('Delete the pixels ?')) {
                // 1. Clear editor table UI
                for (let p = 0; p < pixels.length; p++) {
                  pixels[p].className = '';
                }

                // 2. Reset advance width (jumpData[3] is xAdvance)
                if (!table.jumpData) table.jumpData = [0, 0, 0, editorFont.width];

                /*// 3. Wipe the glyph data so it exports as blank
                const glyph = glyphs.find(g => g.code === editorCharCode);
                if (glyph) {
                  glyph.bytes = new Array(glyph.arrayHeight * glyph.width).fill(0);
                  glyph.width = editorFont.width; // make sure jump table width matches editor width
                  colsole.log('Glyph data cleared', glyph.width, glyph.bytes.length);
                }*/
              }
              break;
            case 'copy': {
              const charNumber = parseInt(prompt('Source char #:'));
              if (isNaN(charNumber)) break;
              const tables = Array.from(document.querySelectorAll('#chars .char-item table'));
              const offset = charNumber - parseInt(document.getElementById('code').value || 0);
              if (offset < 0 || offset >= tables.length) { alert('Invalid source char'); break; }
              const src = tables[offset].getElementsByTagName('td');
              const dst = table.getElementsByTagName('td');
              for (let i = 0; i < dst.length && i < src.length; i++) {
                if (dst[i].parentNode.localName === 'th') continue;
                dst[i].className = src[i].className;
              }
              table.jumpData[3] = xAdv; // recalc after copy if needed
              //waitforGenerateF();
            } break;


          }

          // update the glyph preview immediately
          editorFont.renderGlyphs(3);

          return;
        }

        // ------------------- PAINTING -------------------
        if (action === 'toggle') {
          const cell = e.target;
          if (cell.getAttribute('action') === 'toggle') {
            paintState = !cell.classList.contains('on');
            if (!cell.classList.contains('out')) cell.classList.toggle('on', paintState);
            isMouseDown = true;
          }
        }
      });


      document.getElementById('chars').addEventListener('pointerover', e => {
        if (!isMouseDown) return;
        const cell = e.target; if (cell.getAttribute('action') === 'toggle') {
          if (!cell.classList.contains('out')) cell.classList.toggle('on', paintState);
        }
      });
      document.addEventListener('pointerup', () => { isMouseDown = false; paintState = null; isPaint(event); });
      function isPaint(event) {
        // check if the event target is a paintable cell
        const isPaintable = event.target.tagName === 'TD' &&
          event.target.closest('.char-item'); // make sure it belongs to a glyph

        if (!isPaintable) {
          return;
        }
        waitforGenerateF();
      }
      function waitforGenerateF() {
        if (isGenerating) return;
        if (document.getElementById('liveUpdate').checked) {
          document.getElementById('generate').style.visibility = 'hidden';
          document.getElementById('generate').style.pointerEvents = 'none';
          clearTimeout(generateTimer);

          generateTimer = setTimeout(() => {
            if (!isMouseDown) {
              generateF();
            }
          }, 1500);
        }
        else {
          document.getElementById('generate').style.visibility = 'visible';
          document.getElementById('generate').style.pointerEvents = 'auto';
        }
      }


      let generateTimer = null;
      let isGenerating = false;


    })();

  </script>

</body>

</html>